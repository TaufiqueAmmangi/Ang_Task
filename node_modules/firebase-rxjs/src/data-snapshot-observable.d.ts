import { Observable } from 'rxjs/Observable';
import { DataSnapshot, ExportedSnapshot, Priority } from './interfaces';
export declare function makeDataSnapshotObservable<T>(observable: Observable<DataSnapshot<T>>): DataSnapshotObservable<T>;
export declare class DataSnapshotObservable<T> extends Observable<DataSnapshot<T>> {
    exists(): Observable<boolean>;
    children(): Observable<DataSnapshotObservable<T[keyof T]>>;
    /**
     * This operator takes the result of .val() for all children of the snapshot and emits
     * them as an array.
     * Contents of source snapshot:
     * ```
     * {
     *  childA: { prop: 'Hello' },
     *  childB: { prop: 'World!' },
     * }
     * ```
     * Result of operator:
     * ```
     * [
     *  { prop: 'Hello' },
     *  { prop: 'World!' },
     * ]
     * ```
     * @returns {Observable<C[]>}
     */
    toValArray(): Observable<T[keyof T][]>;
    values(): Observable<T[keyof T][]>;
    keys(): Observable<string[]>;
    list(): Observable<{
        val: T[keyof T];
        key: string;
    }[]>;
    entry(): Observable<{
        val: T;
        key: string | null;
    }>;
    key(): Observable<string | null>;
    /**
     * When listening to events such as {@link Event.ChildMoved} the snapshot includes
     * the key of the child before this snapshots one. This operator maps to this key.
     * @returns {Observable<string>}
     */
    prevKey(): Observable<string>;
    val(): Observable<T>;
    getPriority(): Observable<Priority>;
    exportVal(): Observable<ExportedSnapshot<T>>;
    hasChild(path: keyof T): Observable<boolean>;
    hasChildren(): Observable<boolean>;
    numChildren(): Observable<number>;
    child<P extends keyof T>(path: P): DataSnapshotObservable<T[P]>;
}
