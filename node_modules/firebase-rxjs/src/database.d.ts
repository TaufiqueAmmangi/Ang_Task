import { database } from 'firebase';
import { Observable } from 'rxjs/Observable';
import { FirebaseApp } from './app';
import { DataSnapshotObservable } from './data-snapshot-observable';
import { EventType, NativeDatabaseRef, Priority, TransactionResult } from './interfaces';
import { NativeFirebaseDatabase } from './native-firebase';
/**
 * Enum of event types.
 */
export declare class Event {
    static Value: EventType;
    static ChildAdded: EventType;
    static ChildChanged: EventType;
    static ChildRemoved: EventType;
    static ChildMoved: EventType;
}
export declare class FirebaseQuery<T> {
    protected _ref: NativeDatabaseRef;
    protected app: FirebaseApp;
    private query;
    protected wrappedRef: FirebaseDatabaseRef<T>;
    readonly ref: FirebaseDatabaseRef<T>;
    constructor(_ref: NativeDatabaseRef, app: FirebaseApp);
    orderByChild(child: keyof T[keyof T]): FirebaseQuery<T>;
    orderByKey(): FirebaseQuery<T>;
    orderByPriority(): FirebaseQuery<T>;
    orderByValue(): FirebaseQuery<T>;
    startAt(value: number | string | boolean | null, key?: keyof T[keyof T]): FirebaseQuery<T>;
    endAt(value: number | string | boolean | null, key?: keyof T[keyof T]): FirebaseQuery<T>;
    equalTo(value: number | string | boolean | null, key?: keyof T[keyof T]): FirebaseQuery<T>;
    limitToFirst(limit: number): FirebaseQuery<T>;
    limitToLast(limit: number): FirebaseQuery<T>;
    once(event: 'value'): DataSnapshotObservable<T>;
    once(event: 'child_added'): DataSnapshotObservable<T[keyof T]>;
    once(event: 'child_changed'): DataSnapshotObservable<T[keyof T]>;
    once(event: 'child_moved'): DataSnapshotObservable<T[keyof T]>;
    once(event: 'child_removed'): DataSnapshotObservable<T[keyof T]>;
    onceValue(): DataSnapshotObservable<T>;
    onceChildAdded(): DataSnapshotObservable<T[keyof T]>;
    onceChildChanged(): DataSnapshotObservable<T[keyof T]>;
    onceChildMoved(): DataSnapshotObservable<T[keyof T]>;
    onceChildRemoved(): DataSnapshotObservable<T[keyof T]>;
    on(event: 'value'): DataSnapshotObservable<T>;
    on(event: 'child_added'): DataSnapshotObservable<T[keyof T]>;
    on(event: 'child_changed'): DataSnapshotObservable<T[keyof T]>;
    on(event: 'child_moved'): DataSnapshotObservable<T[keyof T]>;
    on(event: 'child_removed'): DataSnapshotObservable<T[keyof T]>;
    onValue(): DataSnapshotObservable<T>;
    onChildAdded(): DataSnapshotObservable<T[keyof T]>;
    onChildChanged(): DataSnapshotObservable<T[keyof T]>;
    onChildMoved(): DataSnapshotObservable<T[keyof T]>;
    onChildRemoved(): DataSnapshotObservable<T[keyof T]>;
    isEqual(query: FirebaseQuery<any>): boolean;
    private _once(event);
    private _on(event);
    protected makeDataSnapshot(snapshot: any, prevKey?: string): any;
    private getEventHandler(sub, complete?);
    private getQueryOrRef();
    private _call(fnName, ...args);
}
export declare class FirebaseDatabaseRef<T> extends FirebaseQuery<T> {
    parent: FirebaseDatabaseRef<any> | null;
    readonly key: string | null;
    constructor(parent: FirebaseDatabaseRef<any> | null, ref: NativeDatabaseRef, app: FirebaseApp);
    child<P extends keyof T>(path: P): FirebaseDatabaseRef<T[P]>;
    set(value: T): Observable<void>;
    setPriority(priority: Priority): Observable<void>;
    setWithPriority(newVal: T, priority: Priority): Observable<void>;
    push<P extends T[keyof T]>(value?: P): Observable<FirebaseDatabaseRef<P>>;
    update(value: T): Observable<void>;
    remove(): Observable<void>;
    transaction(transactionHandler: (node: T | null) => T | null | never, applyLocally?: boolean): Observable<TransactionResult<T>>;
}
/**
 * A special object with information about the connection between client and server which can be
 * accessed by using `db.ref('.info')`.
 */
export declare class InfoSchema {
    /**
     * Whether or not the client is connected to the server.
     */
    connected: boolean;
    /**
     * The estimated offset of time in milliseconds between client and server.
     */
    serverTimeOffset: number;
}
export declare class FirebaseDatabase<T> {
    private db;
    private app;
    /**
     * A collection of special constants which can be used when writing data. Their values will be
     * substituted on the server with server generated values.
     * E.g {@link FirebaseDatabase.ServerValue.TIMESTAMP} will be substituted for the server time
     * when committing a write.
     */
    static ServerValue: typeof database.ServerValue;
    constructor(db: NativeFirebaseDatabase, app: FirebaseApp);
    /**
     * Get a {@link FirebaseDatabaseRef} to a location in the database.
     *
     * @howToUse
     * If you have defined a database schema you should use {@link FirebaseDatabase.ref} without
     * specifying a path in the database. At least not without giving a type parameter for the data
     * at that location. When using a schema you get the benefit of correct typing when using
     * {@link FirebaseDatabaseRef.child}. The TypeScript compiler can infer from the path segments
     * given to {@link FirebaseDatabaseRef.child} whether the path segment is valid at this
     * location in the database and what the type of the data is that will be returned when
     * fetching it.
     */
    ref(): FirebaseDatabaseRef<T>;
    ref(path: '.info'): FirebaseDatabaseRef<InfoSchema>;
    ref(path: string): FirebaseDatabaseRef<any>;
    ref<F>(path: string): FirebaseDatabaseRef<F>;
}
